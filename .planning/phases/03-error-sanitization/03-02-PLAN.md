---
phase: 03-error-sanitization
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/workshop_mcp/server.py
  - tests/test_error_sanitization.py
autonomous: true

must_haves:
  truths:
    - "ValueError exceptions return 'Invalid parameters' not str(exc)"
    - "FileNotFoundError exceptions return 'Resource not found' not str(exc)"
    - "SyntaxError exceptions return 'Invalid source code syntax' not str(exc)"
    - "KeyError exceptions return 'Missing required argument' not str(exc)"
    - "Parse errors return 'Parse error' without exception details"
    - "Internal errors include correlation_id but not str(exc)"
    - "Full error details are logged with correlation ID"
    - "SecurityValidationError messages are passed through (already safe)"
  artifacts:
    - path: "src/workshop_mcp/server.py"
      provides: "Sanitized error handling"
      contains: ["request_context", "CorrelationIdFilter", "Invalid parameters", "Resource not found"]
    - path: "tests/test_error_sanitization.py"
      provides: "Test coverage for error sanitization"
      min_lines: 100
  key_links:
    - from: "src/workshop_mcp/server.py"
      to: "src/workshop_mcp/logging_context.py"
      via: "import request_context"
      pattern: "from.*logging_context.*import.*request_context"
    - from: "src/workshop_mcp/server.py"
      to: "logging"
      via: "CorrelationIdFilter attached to handler"
      pattern: "addFilter.*CorrelationIdFilter"
---

<objective>
Integrate error sanitization into the MCP server to prevent information disclosure via error messages.

Purpose: Fix all 6 identified exception leak points in server.py by replacing str(exc) with generic messages, wrapping tool execution with correlation ID context, and configuring logging to include correlation IDs.

Output: server.py with secure error handling, all leak points fixed, and tests proving no internal details leak.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-error-sanitization/03-RESEARCH.md
@.planning/phases/03-error-sanitization/03-01-SUMMARY.md
@src/workshop_mcp/server.py
@src/workshop_mcp/logging_context.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error sanitization tests</name>
  <files>tests/test_error_sanitization.py</files>
  <action>
    Create comprehensive tests that verify no internal details leak in error responses.

    Test categories:
    1. **ValueError sanitization** - Verify str(exc) not in response
       - Trigger ValueError with revealing message (e.g., file path)
       - Assert response contains "Invalid parameters" not the exception message

    2. **FileNotFoundError sanitization** - Verify path not exposed
       - Trigger FileNotFoundError with path in message
       - Assert response contains "Resource not found" not the path

    3. **SyntaxError sanitization** - Verify code details not exposed
       - Trigger SyntaxError with line info
       - Assert response contains "Invalid source code syntax" not details

    4. **KeyError sanitization** - Verify key name not exposed
       - Trigger KeyError for missing required argument (dictionary access)
       - Assert response contains "Missing required argument" without key name
       - Note: KeyError from dictionary access is distinct from other KeyErrors; both map to generic messages

    5. **Parse error sanitization** - Verify JSON error details hidden
       - Send malformed JSON
       - Assert response contains "Parse error" without json.JSONDecodeError details

    6. **Internal error sanitization** - Verify correlation_id present but no str(exc)
       - Trigger unexpected exception (e.g., via mock)
       - Assert response includes correlation_id but not exception message

    7. **SecurityValidationError passthrough** - Verify safe messages pass through
       - Trigger PathValidationError
       - Assert response contains the security exception's safe message

    8. **Correlation ID logging** - Verify full details logged internally
       - Trigger error with caplog fixture
       - Assert log contains correlation ID and full exception details

    Use WorkshopMCPServer._serve_once() or _handle_request() for testing.
    Mock tools/paths to trigger specific exceptions.
  </action>
  <verify>Tests should fail initially (expected - tests written before fixes)</verify>
  <done>Test file exists with assertions that check for generic messages and absence of internal details</done>
</task>

<task type="auto">
  <name>Task 2: Configure logging with correlation ID filter</name>
  <files>src/workshop_mcp/server.py</files>
  <action>
    Update the logging configuration at the top of server.py to include correlation IDs.

    Changes:
    1. Import from logging_context:
       ```python
       from .logging_context import CorrelationIdFilter, request_context, correlation_id_var
       ```

    2. Update logging.basicConfig to include correlation_id in format:
       ```python
       logging.basicConfig(
           level=logging.INFO,
           format="%(asctime)s - %(name)s - %(levelname)s - [%(correlation_id)s] - %(message)s",
           handlers=[logging.StreamHandler(sys.stderr)],
       )
       ```

    3. Add CorrelationIdFilter to the handler:
       ```python
       # Add correlation ID filter to all handlers
       for handler in logging.root.handlers:
           handler.addFilter(CorrelationIdFilter())
       ```

    Note: The filter must be added AFTER basicConfig creates the handler.
  </action>
  <verify>Server starts without errors: `poetry run workshop-mcp-server &; sleep 1; kill %1`</verify>
  <done>Logging configured with correlation_id format and CorrelationIdFilter attached</done>
</task>

<task type="auto">
  <name>Task 3: Fix all exception leak points</name>
  <files>src/workshop_mcp/server.py</files>
  <action>
    Fix all 6 identified leak points with generic messages. Wrap tool execution in request_context().

    **Leak point 1 (line ~101 in _serve_once):**
    BEFORE: JsonRpcError(-32603, "Internal error", {"details": str(exc)})
    AFTER:  JsonRpcError(-32603, "Internal error", {"correlation_id": correlation_id_var.get()})
    Also wrap the entire _serve_once in request_context().

    **Leak point 2 (line ~138 in _read_message):**
    BEFORE: JsonRpcError(-32700, "Parse error", {"details": str(exc)})
    AFTER:  JsonRpcError(-32700, "Parse error")
    Log the actual parse error at WARNING level before raising.

    **Leak point 3 (line ~330 in _execute_keyword_search):**
    BEFORE: JsonRpcError(-32602, "Missing required argument", {"missing": str(exc)})
    AFTER:  JsonRpcError(-32602, "Missing required argument")
    Log which argument was missing at WARNING level.

    **Leak points 4 & 5 (lines ~416, ~523 - ValueError/FileNotFoundError/SyntaxError/KeyError):**
    BEFORE: JsonRpcError(-32602, str(exc))
    AFTER:  Map exception type to generic message:
            - ValueError -> "Invalid parameters"
            - FileNotFoundError -> "Resource not found"
            - SyntaxError -> "Invalid source code syntax"
            - KeyError -> "Missing required argument"
    Log full exception details at WARNING level before returning.

    NOTE: KeyError mapping applies to both dictionary access KeyErrors (line ~330) and
    any other KeyErrors that might occur during tool execution.

    **Wrap _serve_once in request_context (at outermost level):**
    The context should wrap the ENTIRE _serve_once method so that:
    - Parse errors get correlation IDs
    - Initialization errors get correlation IDs
    - Tool execution errors get correlation IDs
    - ALL errors logged within a request share the same correlation ID

    ```python
    def _serve_once(self, stdin: Any, stdout: Any) -> bool:
        with request_context() as correlation_id:
            try:
                # existing _read_message, _handle_request logic
            except Exception as exc:
                logger.exception("Server loop error")
                # correlation_id_var.get() returns current correlation ID
    ```

    This ensures correlation IDs are available for the outermost exception handler.

    **Important:** SecurityValidationError (PathValidationError, RegexValidationError, etc.)
    already have safe messages - continue to pass str(e) for these.
  </action>
  <verify>
    # Tests should now PASS (TDD cycle complete - tests written in Task 1, fixes applied in Task 3)
    poetry run pytest tests/test_error_sanitization.py -v
    # Verify specific test classes pass:
    # - test_valueerror_returns_generic_message
    # - test_filenotfounderror_returns_generic_message
    # - test_syntaxerror_returns_generic_message
    # - test_keyerror_returns_generic_message
    # - test_parse_error_no_details
    # - test_internal_error_has_correlation_id
  </verify>
  <done>All 6 leak points return generic messages; full details logged with correlation ID; TDD cycle complete (tests pass)</done>
</task>

</tasks>

<verification>
```bash
# All error sanitization tests pass
poetry run pytest tests/test_error_sanitization.py -v

# All existing tests still pass (no regressions)
poetry run pytest --tb=short

# Type checking passes
poetry run mypy src/workshop_mcp/server.py

# Manual verification: trigger error and check response has no details
echo '{"jsonrpc":"2.0","id":1,"method":"call_tool","params":{"name":"performance_check","arguments":{"source_code":"invalid{{{python"}}}' | poetry run workshop-mcp-server 2>/dev/null | grep -v correlation_id | grep -v "Internal error"
# Should NOT contain Python traceback or "invalid syntax" details
```
</verification>

<success_criteria>
1. No error response contains str(exc) from ValueError, FileNotFoundError, SyntaxError, KeyError
2. Parse errors return "Parse error" without JSON decode details
3. Internal errors include correlation_id but not exception message
4. SecurityValidationError messages pass through (already safe)
5. All errors are logged internally with correlation ID and full details
6. All existing tests pass (no regressions)
7. Server starts and handles requests normally
</success_criteria>

<output>
After completion, create `.planning/phases/03-error-sanitization/03-02-SUMMARY.md`
</output>
