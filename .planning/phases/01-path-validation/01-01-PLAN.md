---
phase: 01-path-validation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/workshop_mcp/security/__init__.py
  - src/workshop_mcp/security/exceptions.py
  - src/workshop_mcp/security/path_validator.py
  - tests/test_path_validator.py
autonomous: true

must_haves:
  truths:
    - "PathValidator rejects paths containing ../ traversal sequences"
    - "PathValidator rejects absolute paths outside allowed roots"
    - "PathValidator accepts paths within allowed roots"
    - "Rejected paths raise PathValidationError with generic message"
    - "Allowed roots are configurable via MCP_ALLOWED_ROOTS environment variable"
  artifacts:
    - path: "src/workshop_mcp/security/__init__.py"
      provides: "Public API exports"
      exports: ["PathValidator", "PathValidationError", "SecurityValidationError"]
    - path: "src/workshop_mcp/security/exceptions.py"
      provides: "Security exception hierarchy"
      contains: "class PathValidationError"
    - path: "src/workshop_mcp/security/path_validator.py"
      provides: "Path validation logic"
      exports: ["PathValidator"]
      min_lines: 50
    - path: "tests/test_path_validator.py"
      provides: "Test coverage for path validation"
      min_lines: 80
  key_links:
    - from: "src/workshop_mcp/security/path_validator.py"
      to: "pathlib.Path"
      via: "resolve() and is_relative_to()"
      pattern: "Path\\(.*\\)\\.resolve\\(\\)"
    - from: "src/workshop_mcp/security/path_validator.py"
      to: "os.environ"
      via: "environment variable loading"
      pattern: "os\\.environ\\.get\\([\"']MCP_ALLOWED_ROOTS"
---

<objective>
Create the PathValidator security module using test-driven development.

Purpose: Establish the foundational path validation that prevents arbitrary file read via directory traversal attacks. This module will be used by server.py to validate all file_path and root_paths parameters before tool execution.

Output: Working PathValidator class with comprehensive test coverage, following patterns from 01-RESEARCH.md.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-path-validation/01-RESEARCH.md

# Existing code patterns to follow
@src/workshop_mcp/server.py
@src/workshop_mcp/performance_profiler/__init__.py
</context>

<feature>
  <name>PathValidator with TDD</name>
  <files>
    src/workshop_mcp/security/exceptions.py
    src/workshop_mcp/security/path_validator.py
    src/workshop_mcp/security/__init__.py
    tests/test_path_validator.py
  </files>
  <behavior>
    PathValidator validates file paths are within allowed directories.

    Test cases (RED phase - write these first):

    1. Traversal rejection:
       - validate("../etc/passwd") -> raises PathValidationError
       - validate("foo/../../../etc/passwd") -> raises PathValidationError
       - validate("./valid/./path") -> returns resolved Path (dots are OK)

    2. Absolute path rejection:
       - With allowed_root=["/home/user/project"]:
         - validate("/etc/passwd") -> raises PathValidationError
         - validate("/home/user/project/src/file.py") -> returns resolved Path

    3. Environment variable configuration:
       - With MCP_ALLOWED_ROOTS="/path1:/path2":
         - PathValidator() loads both roots
       - With MCP_ALLOWED_ROOTS not set:
         - PathValidator() defaults to cwd

    4. Error messages are generic:
       - PathValidationError message is "Path is outside allowed directories" or "Invalid file path"
       - No path details in exception message

    5. validate_multiple():
       - validate_multiple(["/valid/a", "/valid/b"]) -> returns [Path, Path]
       - validate_multiple(["/valid/a", "../evil"]) -> raises on second path

    6. validate_exists():
       - validate_exists("nonexistent.py") -> raises PathValidationError("File not found")
       - validate_exists("existing_dir/", must_be_file=True) -> raises PathValidationError
  </behavior>
  <implementation>
    After tests fail (RED), implement:

    1. exceptions.py:
       - SecurityValidationError(Exception) base class
       - PathValidationError(SecurityValidationError) with generic default message

    2. path_validator.py:
       - PathValidator class with:
         - __init__(allowed_roots: Optional[List[Path]] = None)
         - _load_from_env() -> List[Path]
         - validate(path: str) -> Path
         - validate_multiple(paths: List[str]) -> List[Path]
         - validate_exists(path: str, must_be_file: bool = False) -> Path
       - Use Path.resolve() for canonicalization
       - Use Path.is_relative_to() for containment check
       - Log rejected paths internally, return generic error externally

    3. __init__.py:
       - Export PathValidator, PathValidationError, SecurityValidationError

    Follow patterns from 01-RESEARCH.md "Complete PathValidator Implementation" section.
  </implementation>
</feature>

<verification>
```bash
# Run tests - should pass
poetry run pytest tests/test_path_validator.py -v

# Type checking
poetry run mypy src/workshop_mcp/security/

# All existing tests still pass
poetry run pytest --tb=short
```
</verification>

<success_criteria>
- All PathValidator tests pass
- Type hints complete (mypy passes)
- PathValidator rejects traversal attempts with generic error
- PathValidator loads allowed roots from MCP_ALLOWED_ROOTS env var
- Existing 102 tests unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/01-path-validation/01-01-SUMMARY.md`
</output>
