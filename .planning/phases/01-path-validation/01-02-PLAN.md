---
phase: 01-path-validation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/workshop_mcp/server.py
  - tests/test_mcp_server_integration.py
autonomous: true

must_haves:
  truths:
    - "keyword_search tool rejects paths outside allowed directories"
    - "performance_check tool rejects file_path outside allowed directories"
    - "Rejected paths return JSON-RPC error -32602 with generic message"
    - "Valid paths within allowed roots work as before"
  artifacts:
    - path: "src/workshop_mcp/server.py"
      provides: "Server with path validation integration"
      contains: "from workshop_mcp.security import PathValidator"
    - path: "tests/test_mcp_server_integration.py"
      provides: "Integration tests for path validation in MCP context"
      contains: "test_keyword_search_rejects_traversal"
  key_links:
    - from: "src/workshop_mcp/server.py"
      to: "src/workshop_mcp/security/path_validator.py"
      via: "PathValidator instance in __init__"
      pattern: "self\\.path_validator = PathValidator\\(\\)"
    - from: "src/workshop_mcp/server.py._execute_keyword_search"
      to: "PathValidator.validate_multiple"
      via: "validates root_paths before tool execution"
      pattern: "self\\.path_validator\\.validate_multiple\\(root_paths\\)"
    - from: "src/workshop_mcp/server.py._execute_performance_check"
      to: "PathValidator.validate_exists"
      via: "validates file_path before tool execution"
      pattern: "self\\.path_validator\\.validate_exists\\(file_path"
---

<objective>
Integrate PathValidator into the MCP server to validate all path parameters before tool execution.

Purpose: Wire the security module created in Plan 01 into the server layer, ensuring all file_path and root_paths parameters are validated before being passed to tools. This completes the path traversal protection.

Output: Server.py with path validation on both tools, plus integration tests proving protection works end-to-end.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-path-validation/01-RESEARCH.md
@.planning/phases/01-path-validation/01-01-SUMMARY.md

# Files to modify
@src/workshop_mcp/server.py
@tests/test_mcp_server_integration.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate PathValidator into WorkshopMCPServer</name>
  <files>src/workshop_mcp/server.py</files>
  <action>
    Modify server.py to validate paths before tool execution:

    1. Add import at top of file:
       ```python
       from .security import PathValidator, PathValidationError
       ```

    2. In WorkshopMCPServer.__init__(), add:
       ```python
       self.path_validator = PathValidator()
       ```

    3. In _execute_keyword_search(), after type validation but before tool execution:
       ```python
       # Validate paths before tool execution
       try:
           self.path_validator.validate_multiple(root_paths)
       except PathValidationError as e:
           return self._error_response(
               request_id,
               JsonRpcError(-32602, str(e))  # Generic message
           )
       ```

    4. In _execute_performance_check(), after validating file_path is provided but before creating PerformanceChecker:
       ```python
       if file_path:
           try:
               self.path_validator.validate_exists(file_path, must_be_file=True)
           except PathValidationError as e:
               return self._error_response(
                   request_id,
                   JsonRpcError(-32602, str(e))  # Generic message
               )
       ```

    Important: Keep existing type validation intact. Path validation is ADDITIONAL security, not replacement.
    Important: Use str(e) for error message - PathValidationError is designed to have safe messages.
  </action>
  <verify>
    ```bash
    # Type checking
    poetry run mypy src/workshop_mcp/server.py

    # Existing tests still pass
    poetry run pytest tests/test_mcp_server_integration.py -v
    ```
  </verify>
  <done>
    - PathValidator imported and instantiated in server
    - _execute_keyword_search validates root_paths
    - _execute_performance_check validates file_path
    - Type checking passes
    - Existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for path validation</name>
  <files>tests/test_mcp_server_integration.py</files>
  <action>
    Add integration tests that verify path validation works through the MCP protocol:

    ```python
    def test_keyword_search_rejects_traversal(server):
        """Path traversal in root_paths should be rejected."""
        request = {
            "jsonrpc": "2.0",
            "id": 1,
            "method": "call_tool",
            "params": {
                "name": "keyword_search",
                "arguments": {
                    "keyword": "test",
                    "root_paths": ["../../../etc"]
                }
            }
        }
        # Use server.serve_once or equivalent pattern from existing tests
        # Expect error response with code -32602

    def test_keyword_search_rejects_absolute_outside_root(server):
        """Absolute paths outside allowed roots should be rejected."""
        request = {
            "jsonrpc": "2.0",
            "id": 2,
            "method": "call_tool",
            "params": {
                "name": "keyword_search",
                "arguments": {
                    "keyword": "test",
                    "root_paths": ["/etc/passwd"]
                }
            }
        }
        # Expect error response with code -32602

    def test_performance_check_rejects_traversal(server):
        """Path traversal in file_path should be rejected."""
        request = {
            "jsonrpc": "2.0",
            "id": 3,
            "method": "call_tool",
            "params": {
                "name": "performance_check",
                "arguments": {
                    "file_path": "../../../etc/passwd"
                }
            }
        }
        # Expect error response with code -32602

    def test_keyword_search_accepts_valid_relative_path(server, tmp_path):
        """Valid relative paths within allowed roots should work."""
        # Create a temp directory structure
        # Set MCP_ALLOWED_ROOTS to include tmp_path
        # Verify search works

    def test_performance_check_accepts_valid_file(server, tmp_path):
        """Valid file_path within allowed roots should work."""
        # Create a temp Python file
        # Set MCP_ALLOWED_ROOTS to include tmp_path
        # Verify analysis works
    ```

    Follow the existing test patterns in the file. Use pytest fixtures and the server setup pattern already established.

    Important: Tests should verify:
    1. Error response has code -32602
    2. Error message is generic (no path details leaked)
    3. Valid paths still work (regression prevention)
  </action>
  <verify>
    ```bash
    # New tests pass
    poetry run pytest tests/test_mcp_server_integration.py -v -k "traversal or rejects or accepts_valid"

    # All tests pass
    poetry run pytest --tb=short
    ```
  </verify>
  <done>
    - At least 5 new integration tests for path validation
    - Tests verify traversal rejection
    - Tests verify absolute path rejection
    - Tests verify valid paths still work
    - All 102+ tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# All tests pass
poetry run pytest --tb=short

# Type checking
poetry run mypy src/workshop_mcp/

# Verify traversal is actually blocked (manual sanity check)
# This would fail before the fix, succeed after:
# export MCP_ALLOWED_ROOTS="$(pwd)"
# Then try to access ../etc/passwd via the MCP server
```
</verification>

<success_criteria>
- PathValidator integrated into server.py __init__
- keyword_search validates root_paths before execution
- performance_check validates file_path before execution
- Integration tests prove traversal attacks are blocked
- All existing tests pass (no regressions)
- Error messages are generic (no path leakage)
</success_criteria>

<output>
After completion, create `.planning/phases/01-path-validation/01-02-SUMMARY.md`
</output>
